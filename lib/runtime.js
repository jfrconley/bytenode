const vm = require('node:vm');
const {gunzipSync, gzipSync} = require('node:zlib');
const {ok} = require('node:assert');

const MAGIC_NUMBER = Buffer.from([0xde, 0xc0]);
const ZERO_LENGTH_EXTERNAL_REFERENCE_TABLE = Buffer.alloc(2);


/**
 * Generates v8 bytecode buffer.
 * @param   {string} javascriptCode JavaScript source that will be compiled to bytecode.
 * @param   {boolean} compress Compress the bytecode.
 * @returns {Buffer} The generated bytecode.
 */
const compileCode = function (javascriptCode, compress) {
    if (typeof javascriptCode !== 'string') {
        throw new Error(`javascriptCode must be string. ${typeof javascriptCode} was given.`);
    }

    const script = new vm.Script(javascriptCode, {
        produceCachedData: true
    });

    let bytecodeBuffer = (script.createCachedData && script.createCachedData.call)
        ? script.createCachedData()
        : script.cachedData;

    if (compress) bytecodeBuffer = gzipSync(bytecodeBuffer);

    return bytecodeBuffer;
};

function generateScript(cachedData, filename) {
    if (!isBufferV8Bytecode(cachedData)) {
        // Try to decompress as Brotli
        cachedData = gunzipSync(cachedData);

        ok(isBufferV8Bytecode(cachedData), 'Invalid bytecode buffer');
    }

    fixBytecode(cachedData);

    const length = readSourceHash(cachedData);

    let dummyCode = '';

    if (length > 1) {
        dummyCode = '"' + '\u200b'.repeat(length - 2) + '"'; // "\u200b" Zero width space
    }

    const script = new vm.Script(dummyCode, {cachedData, filename});

    if (script.cachedDataRejected) {
        throw new Error('Invalid or incompatible cached data (cachedDataRejected)');
    }

    return script;
}

function isBufferV8Bytecode(buffer) {
    return (
        Buffer.isBuffer(buffer) &&
        !buffer.subarray(0, 2).equals(ZERO_LENGTH_EXTERNAL_REFERENCE_TABLE) &&
        buffer.subarray(2, 4).equals(MAGIC_NUMBER)
    );

    // TODO: check that code start + payload size = buffer length. See
    //       https://github.com/bytenode/bytenode/issues/210#issuecomment-1605691369
}

// TODO: rewrite this function
const readSourceHash = function (bytecodeBuffer) {
    if (!Buffer.isBuffer(bytecodeBuffer)) {
        throw new Error('bytecodeBuffer must be a buffer object.');
    }

    if (process.version.startsWith('v8.8') || process.version.startsWith('v8.9')) {
        // Node is v8.8.x or v8.9.x
        // eslint-disable-next-line no-return-assign
        return bytecodeBuffer.subarray(12, 16).reduce((sum, number, power) => sum += number * Math.pow(256, power), 0);
    } else {
        // eslint-disable-next-line no-return-assign
        return bytecodeBuffer.subarray(8, 12).reduce((sum, number, power) => sum += number * Math.pow(256, power), 0);
    }
};

function getDummyBytecode() {
    return compileCode('"ಠ_ಠ"').subarray(12, 24);
}

const fixBytecode = function (bytecodeBuffer) {
    if (!Buffer.isBuffer(bytecodeBuffer)) {
        throw new Error('bytecodeBuffer must be a buffer object.');
    }

    const dummyBytecode =  getDummyBytecode();
    const version = parseFloat(process.version.slice(1, 5));

    if (process.version.startsWith('v8.8') || process.version.startsWith('v8.9')) {
        dummyBytecode.subarray(4, 8).copy(bytecodeBuffer, 16);
        dummyBytecode.subarray(8, 12).copy(bytecodeBuffer, 20);
    } else if (version >= 12 && version <= 21) {
        dummyBytecode.subarray(0, 4).copy(bytecodeBuffer, 12);
    } else {
        dummyBytecode.subarray(0, 4).copy(bytecodeBuffer, 12);
        dummyBytecode.subarray(4, 8).copy(bytecodeBuffer, 16);
    }
};

module.exports = {
    generateScript,
    readSourceHash,
    fixBytecode,
    compileCode,
    getDummyBytecode,
}
